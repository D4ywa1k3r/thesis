\section{Scope of secrets}
\label{ch:theory:scope_secrets}
In order to steer the work in a specific direction, it is necessary to set a scope of secrets which has to be discovered. A brief definition of this topic will be evaluated in this segment.

Software developers and system engineers are the main stakeholders who create container images regularly. Nowadays the technical environments are often cloud services. Many of the cloud service players are Amazon, Microsoft and Google. There are many more service providers available. The following list points out the central common features of these global players.
\begin{itemize}
\item Compute Engine - Includes virtual machines or clusters
\item Kubernetes Engine - Includes Kubernetes components
\item Storage - Includes several types of databases and hardware provisioning
\item Diverse - Networking, Monitoring, Artificial Intelligence, BigData, etc ...
\end{itemize}

This is a large bundle of functions provided by each individual cloud provider that can be used within a container and thus in an image.
There are many other APIs accessible, apart from the obvious features. For example Google offers more than 100 API's for developers.
Fortunately each cloud provider has Identity and Access Management (IAM) integrated for providing the principle of least privilege. But this is at the discretion of the operator.

In order to perform actions via these API's and services, authentication is required beforehand. Google, Microsoft and Amazon have established several kinds of authentication. 
The developer has to choose application credentials based on what the application needs and where it runs.
The ranges of credentials is big and contains amongst others credentials API keys, OAuth 2.0 client authentication, environment-provided service accounts and other types of tokens which are derived from an associated technical user.
Since access keys are nowadays often used by developers directly in the code, the API token gets a special consideration in this paper.
It only plays a secondary role, whether the token comes from Google, Microsoft or Amazon. When it comes to the analysis it is important is to recognize a corresponding architecture or scheme of the token.
In this thesis an API token from Amazon is investigated. An adaptation to other tokens is also possible when the schema is determined and adapted.
Amazon itself uses a combination of an access key and secret token which is normally directly used in the code.

To be independent of a global player, most of all solutions can also be used by subscribing to these services directly from the associated vendor.
As a last resort most of all available solutions can be maintained bare-metal.
In every case the authentication depends on possible options of the software itself. Simple authentication via user name and password is still common, as well as authentication via certificates.
Certificates themselves are flexible, versatile to use and therefore popular. The asymmetric mechanism behind this is usually RSA. RSA is widely used and still the state of art when confidentiality or authenticity
is needed. In a RSA key pair, the private key is finally the sensible part which is responsible for the protection goals. 
Due to the popularity and important use cases of the RSA private key turns into a second popular candidate in this work.

RSA keys are usually created with e.g. client tools like openssl or ssh-keygen. The folder and filename can be changed with passing correct command line arguments to the programs which makes the place and name of the private key arbitrary. The key file can be placed and named whereever the developer sees the necessity. The program which requires the key needs only a correct configuration to find the keyfile. Only the content of the keys counts and has to be untouched. 
Tools like openssl and ssh-keygen have in common that generated keys are stored on the filesystem. It might be theoretically possible to extract these keys as a plain string and integrate it in a source code, but it is serious design mistake which needs a great deal of effort. Therefore the scope of this work for private keys is only on file system level with consideration of arbitrary locations and names.
It has to be considered that RSA keys normally should contain a passphrase to provide additional security in case someone steals the private key file. The passphrase is just a key being used to encrypt the file that contains the RSA key, using a symmetric cipher (usually DES or 3DES). The used symmetric cipher can be examined by reviewing the header of the private key. To use the private key for public key encryption, the file must first be decrypted with the decryption key.
If the private key itself is password protected (additional passphrase), then this passphrase must also be made available to the container so that the private key can be used. Otherwise a password request exists and the container does not work automatically. 
The passphrase in general can be accessed from different sources like a file, an environment variable or another stream which can be piped into the tool like ssh which uses the private key file.
In container/image context the passphrase can be integrated during runtime to the container or as a static file itself into the image. A runtime integration offers the same hurdle as a dictionary attack when it comes to crack the password since the password is provided by the orchestrator and therefore not directly accessible. This top-down method does not usually lead to efficient success. If instead a static integration into the image is done it would leads to the possibility to compromise the passphrase of the private key part. 
Passphrases are arbitrarily chosen and does not follow a syntax. Therefore no key based search or pattern-based search is possible to find these passwords. This is another hurdle to find the password but is still possible because it is statically integrated. The scope of this theoretical concept is still to find secrets which use a fix schema. The discussion part will provide more informations about this case of setting a passphrase on a private key.

To summarize these two types of secrets, the API-access token from Amazon is a set of sensitive key pair while the RSA private key alone is very sensible. 
Due to the nature of inserting API tokens in plain text into source code, this is a different level compared to RSA private keys that exists on a file system.
These two types of keys define the target to be detected in the images.

