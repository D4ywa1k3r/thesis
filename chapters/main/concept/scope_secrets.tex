\section{Scope of secrets}
\label{ch:theory:scope_secrets}
In order to steer the work in a specific direction, a scope of secrets to discover is necessary. In this section, this is briefly and meaningfully defined.

Software developers and system engineers are the main stakeholders who are creating container images regularly. The technical environment are often cloud services nowadays. Big cloud service players are Amazon, Microsoft and Google. There are much more service providers available. Common features of those global players shows the following list
\begin{itemize}
\item Compute Engine - Includes virtual machines or clusters
\item Kubernetes Engine - Includes Kubernetes components
\item Storage - Includes several types of databases and hardware provisioning
\item Diverse - Networking, Monitoring, Artificial Intelligence, BigData, etc ...
\end{itemize}

This is a large bundle of functions provided by each individual cloud provider that can be used within a container and thus in an image.
Apart from the obvious features there are many other APIs accessible. Google offers as an example more than 100 API's for developers.
Fortunately each cloud provider has also Identity and Access Management (IAM) integrated for providing the principle of least privilege. But that's at the discretion of the operator.

In order to perform actions via these API's and services, authentication is required beforehand. Google, Microsoft and Amazon have established several kinds of authentication. 
The developer has to choose application credentials based on what the application needs and where it runs.
The ranges of credentials is big and contains amongst others credentials API keys, OAuth 2.0 client authentication, environment-provided service accounts and other types of tokens which are derived from an associated technical user.
Since access keys are nowadays often used by developers directly in the code, the API token gets a special consideration in this paper.
Whether the token comes from Google, Microsoft or Amazon only plays a secondary role. Important with the token is to recognize a corresponding architecture or scheme when it comes to the analysis.
In this thesis an API token from Amazon is investigated. An adaptation to other tokens is also possible when the schema is determined and adapted.
Amazon itself uses a combination of an access key and secret token which is normally directly used in the code.

To be independent of a global player, most of all solutions can be also used by subscribing to these services directly from the associated vendor.
As a last resort most of all available solutions can be maintained bare-metal.
In every case the authentication depends on possible options of the software itself. Simple authentication via user name and password is still common, as well as authentication via certificates.
Certificates themselves are flexible, versatile to use and therefore popular. The asymmetric mechanism behind is usually RSA. RSA is widely used and still the state of the art when confidentiality or authenticity
is needed. In a RSA key pair, the private key is finally the sensible part, which is responsible for the protection goals. 
Due to the popularity and important use cases of the RSA private key, it becomes a second popular candidate in this work.

RSA keys are usually created with e.g. client tools like openssl or ssh-keygen. The folder and filename can be changed with passing correct command line arguments to the programs. That makes the place and name of the private key arbitrary. The key file can be placed and named where ever the developer the necessity sees. It just needs a corresponding correctly configured client to find the key file. Only the content of the keys counts and has to be untouched. 
Tools like openssl and ssh-keygen have in common that generated keys are stored on the filesystem. It might be theoretically possible to extract these keys as a plain string and integrate it in a source code, but it is serious design mistake and needs also much effort. Therefore the scope of this work for private keys is only on file system level, with consideration of arbitrary locations and names.
It has to be considered, that RSA keys normally should contain a passphrase to provide additional security in case someone makes off with the private key file. The passphrase is just a key used to encrypt the file that contains the RSA key, using a symmetric cipher (usually DES or 3DES). The used symmetric cipher can be examined by reviewing the header of the private key. In order to use the private key for public-key encryption, it is first needed to decrypt its file using the decryption key.
If an additional passphrase is included above the private key, it must also be included in the container so that the private key can be used. Otherwise a password request exists and the container does not work automatically. 
The passphrase in general can be accessed from different sources like a file, an environment variable or another stream and piped into the tool like ssh which uses the private key file.
In container/image context, the passphrase can be integrated during runtime to the container or as a static file itself into the image. A runtime integration offers the same hurdle as a dictionary attack when it comes to crack the password, since the password is provided by the orchestrator itself and therefore not directly accessible. This top-down method does not usually lead to efficient success. If instead a static integration into the image is done, this leads to the possibility to compromise the passphrase of the private key part. 
Passphrase are arbitrarily chosen and does not follow a syntax. Therefore no key based search oder pattern-based search is possible to find these passwords. This is another hurdle to find the password, but still possible because it is statically integrated. The scope of this theoretical concept is still to find secrets which use a fix schema. The discussion part will provide more informations about this case of setting a passphrase on a private key.

To summarize these two types of secrets, the API-access token from Amazon is sensitive key pair while the RSA private key alone is very sensible. 
Due to the nature of inserting API tokens in plain text into source code, this is a different level compared to RSA private keys that exist on a file system.
These two types of keys define the target to be detected in the images.

